1. Intro
Script de interno osea va dentro de la hoja de HTML


--------------------------------------------------------------------------------------
2. Refactorizar
hacer que el codigo sea mas entedible y que tenga mejor rendimiento




--------------------------------------------------------------------------------------
3. Varibles
 Var   --> Para definir variables, pero este ya casi no se usa
 let   --> Para definir Varibles, si se puede reasignar, pero no se pude declarar de nuevo
 const --> Para definir Varibles pero estas no se puede reasignar, pero si puden modificarse sus propiedades

 En resumen r√°pido
Palabra	      Reasignar	    Redeclarar	   Alcance (scope)		        Uso actual
var	             ‚úÖ	          ‚úÖ	            Funci√≥n	                  ‚ùå Evitar
let	             ‚úÖ	          ‚ùå	            Bloque {}	                ‚úÖ
const	         ‚ùå	          ‚ùå	            Bloque {}	                ‚úÖ (por defecto)



convenciones para definir variables
1.UpperCamelCase --> la primera letra del nombre de la variable es Mayuscula y si existe otra palabra tambien 
debe ser mayuscula la primera letra

2.camelCase --> la primera letra del nombre de la variable es minuscula y si existe otra palabra debe ser mayuscula la primera 

3.snake_case --> esta se separa las palabras por un guion bajo "_" y todas las palabra debe ser mayuscula


la que usare yo es la 2. camelCase porque me siento mas comodo :)


JavaScript es "Case Sensitive" lo cual Distingue may√∫sculas y min√∫sculas





-------------------------------------------------------------------------------------------

3.Tipos de datos
1.Primitivos
- Number
- String
- Boolean
- Undefined
- Null

2.De Referencia
- Array
- Object
- Functions
- Clases


stack --> se guardan los datos de 1. Primitivos
heap --> se guardan los datos 2.De Referencia



--------------------------------------------------------------------------------------

Tipos de datos Primitivos

let numero = 1; // 1.Tipo Number es de Numero

let texto = "Hola"; // 2.Tipo String es de texto

let verdadero = true; // 3.Tipo Boolean es verdadero o falso

let falso = false; // 3.1 Tipo Boolean es falso o verdadero

let noDefinido; // 4.dice any pero es undefined osea no tien un valor

let undef = undefined; // 4.1 undefined pero es undefined osea no tiene un valor

let nulo = null; // 5. tiene un valor pero el valor es nulo no undefined



en una variable esta:

let nombre = "Adelso";

1.esta el tipo de dato que es valor que tiene: Number, String, Boolean, Undefined y Null pero la variable "nombre" es un "String"
2.esta el valor que se le signa a la variable en este caso "Adelso" es el valor de la variable "nombre"



-----------------------------------------------------------------------------------------------------------

con la variable "let" se puede hacer lo siguiente

let nombre = "Hola de Nuevo"; //las variables let puede reasignarse de nuevo
nombre = "Hello :D"           //se reasigan un nuevo valor a la variable

console.log(nombre);


Con la variable "const" se puede hacer lo siguiente
const nombre = "Hola de Nuevo"; //las variables let no se puede reasignarse de nuevo
nombre = "Hello :D"           //por lo que no se podra cambiar el valor de esa varible

console.log(nombre);


-----------------------------------------------------------------------------------------------------------
Tipos de Lenguajes
1. Tipado Estatico
al momento de definir una varible se aplica el tipo de dato
y este ya no puede cambiar e valor


2. Tipado Dinamico
no es necesario definir el tipo de dato
y este ya se puede cambiar e valor



typeof --> es para verficar el tipo de una varible

Ejemplo;
let numero = 42;
let nombre = "Hola de Nuevo";
let verdadero = true;
let undef;
let nula = null;


console.log(typeof numero);   --> Number
console.log(typeof nombre);   --> String
console.log(typeof verdadero); --> Boolean
console.log(typeof undef);    --> undefined
console.log(typeof nula);    --> nula pero sale "Object" porque al final es un valor "0"   




-----------------------------------------------------------------------------------------------------------

Objetos 
Estos son tipos de Referencia, ya que unicamente de guardara una Referencia, no es un dato primitivo
Los objetos se reconcen cuando se usan llaves "{}"

//Personaje de un Anime de Demon Slayer
let nombre = "Tanjiro";  
let anime = "Demon Slayer"; 
let edad = 16;  


//Uso de Objeto "{}" de un Personaje 
var personaje = {
     nombre: "Tanjiro",  // no es nesario escribir let ya que estos datos son propiedades del objeto
     anime: "Demon Slayer", //no se usa "=", se usa ":"
     edad: 16,             // y se separa con una "," menos la ultima priopiedad
};  //<-- con ello decimo que estamos creando un objeto con las llaves


console.log(personaje); //accede a todo el objeto
console.log(personaje.nombre); //accede a una propiedad del objeto


personaje.edad = 18; //Para poder cambiar una propiedad del objeto, No cambia el Objeto si no una propiedad de el
console.log(personaje.edad); //accede a una propiedad del objeto


delete personaje.anime; //elliminacion de una propiedad del objeto con "delete"

console.log(personaje);




-----------------------------------------------------------------------------------------------------------

//Definicion de un array con "[]"

let ensalada = ["Naranja", "Mango"]; //sus elementos se separan con una "," y sus elementos o index empiezan desde "0"


console.log(ensalada); //accede a todo los elementos

console.log(ensalada[0]); //accede al primer elemento que es "Naranja"

//para anadir un elemento pude ser de varias formas esta 
//Forma 1, agregarlo con su index si sabemos cual es el que sigue
ensalada[2] = "Tomate";

console.log(ensalada);

//Forma 2; con ".push()" y esta es la que usare ya que no se ocupa saber el index
ensalada.push("limon");

console.log(ensalada);


//para conseguir el tama√±o de elementos que tiene mi array lo puedo hacer con ".length"

console.log(ensalada.length);





-----------------------------------------------------------------------------------------------------------

Funciones
Listado de Herramientas que deben ejecutarse

//Funciones
function saludar() {
    console.log("Hola de Nuevo");
}

saludar(); //llamado de la funcion


function suma(){
    return 2 + 2; //return es la salida de una funcion
}

//si llamos a la funcion normnal no se podra ya que es una salida y debe guardarse o entrar en algo

let resultado = suma(); // alojamiento de una funcion de un variable

console.log(resultado); //llamado de la variable con una funcion guardada
console.log(suma()); //llamado de la funcion pero que la muestre



-----------------------------------------------------------------------------------------------------------
//Argumentos y Parametros

/*
function suma(num1, num2) {  //num1, num2: seran parametros de nuestra funcion
    return num1 + num2;
}

let resultado = suma(2, 4); // 2 y 3: son los argumentos

console.log(resultado);
//Esto dara un resultado de 6
*/
//console.log(typeof suma);  --> function


//si quisieras pasarle varios argumentos a nustra funcion
function suma(num1, num2) {  //parametros de nuestra funcion
    
    console.log(arguments); // con arguments podemos ver todos los argumenos que se le pasan a la funcion
    return num1 + num2;
}

let resultado = suma(2, 4, 4 ,6 ,7); //argumentos

console.log(resultado);



-----------------------------------------------------------------------------------------------------------

Declaraciones y Expresiones

1.Declaraciones
1.1 Declaration --> Declaracion oral
1.2 Statement --> Declaracion escrita

Las Declaraciones en JavaScript, es cuando se crea algo pero se referencia en un futuro

1.1 Declaration --> Declaracion oral
- let
- const
- funcion y funcion*
- asyn funcion y asinc funcion*
- class 
- export / import


1.2 Statement --> Declaracion escrita
- if
- elese 
- for
- switch




2.Expresiones
Expressious
Es cualquier linea o expresion de codigo que evalua de un valor

Ejemplo
4 + 6 = 10

x = 10

miFuncion()

Tambien

let, const, if, for ‚Üí Declaraciones / Statements
2 + 2, x = 5, miFuncion() ‚Üí Expresiones



-----------------------------------------------------------------------------------------------------------
Operadores en JavaScript
Sirven para poder crear Expresiones y con ello se crean algoritmos y solucionar problemas

- Aritmeticos
- Asignacion
- Comparacion
- Logicos
- Bitwise




Operadores Aritmeticos
//Operadores Aritmeticos : Para realizar Operaciones Matematicas
let a = 5; //Expresion

let b = 7; //Expresion

/*
//Declaracioon
console.log(a + b); //suma 
console.log(a - b); //resta 
console.log(a * b); //multiplicacion
console.log(a / b); //Division
console.log(a % b); //modulo o el residuo de la division
console.log(a ** b); //potencia


//funcionalidad de console al pasar un argumento string
console.log(a + b, "suma"); 
console.log(a - b, 'resta'); 
*/


//Operadores Incrementar
console.log(++a); //Foma 1 incremento al instante refejado
console.log(a++); //Foma 2 incremento en segunda llamada refelajada
console.log(a); //valor de a


//Operadores Decrementar
console.log(--a); //Foma 1 decremento al instante refejado
console.log(a--); //Foma 2 decremento en segunda llamada refelajada
console.log(a); //valor de a





Operadores de Asignacion
//Operadores de asignacion +=
let a = 5;
a = a + 5; // estamos resignado para poner aumentar un valor

a += 5;
a -= 5;
a *= 5;
a /= 5;
a %= 5;

console.log(a);




Operadores de Comparacion
//Operaciones de Comparacion
//relacionales
let a = 10;

console.log( a > 5); //mayor que a: comparar si es true o false
console.log( a >= 5); //mayor o igual a:comparar si es true o false
console.log( a < 5); //menor que a:comparar si es true o false
console.log( a <= 5); //menor o igual a:comparar si es true o false


//condicionales

console.log(a == 10); // ==: es igual a 10
console.log(a != 10); // !=: es distinto a 10
console.log(a === '10'); // ===: es un igual estricto a '10'





Operadores Logicos
//Operadores Logicos
// AND, OR, NOT
// &&, ||,  !


//AND --> &&
//evalua lo que se encuntra en ambos lados
//console.log(true && true); //Dara true porque ambos lados son true
//console.log(true && false); //Dara false porque los lados no son iguales


let mayor = false;
let suscrito = true;

console.log("Operador AND: ", mayor && suscrito);//false porque ambas no son iguales


//OR
// si no cumple una accion entonces puede cumplir otra
console.log("Operador OR: ", mayor || suscrito);//true poque existe 2 acciones

//NOT
//Invierte el valor
console.log("Operador NOT: ", !mayor); //true porque invierte el valor del false


let catalogoInfantil = !mayor; // solo acceso a ese catalogo



Operadores de Short Circuit
//Use de Operadores vistos --> short-ciruit

//Falso
/* 
- seria el Boolean de false
- 0
- '' , " "
- null
- undefined
- NaN

Todos estos se conocen como "Falsy"
*/

//let nombre = ""; // si se muestra en consola muestra Anonimo porque nombre esta vacio es false
let nombre = "John"; // si se muestra en consola muestra John porque nombre es true no esta vacio
let username = nombre || "Anonimo";
console.log(username);

function fn1(){
    console.log("Soy Funcion 1");
    return false;
}

function fn2(){
    console.log("Soy Funcion 2");
    return true;
}

let funciones = fn1() && fn2(); // solo devolvera la primera funcion ya que ambas no returnan true o no sonm iguales




Operadores de Bitwise
//Operadores de Bitwise

//Decimal: 0,1,2,3,4,5,6,7,8,9
//Binario: 0,1

//bit: es un digito en binario puede ser 0 o 1
//byte: combinacion de 8 bits, puede ser caracteres, simbolos o numeros
//byte: 00000000 -> 0
//byte: 00000001 -> 1
//byte: 00000010 -> 2
//byte: 00000011 -> 3
//byte: 00000100 -> 4
//byte: 00000101 -> 5
//byte: 00000110 -> 6

//Existe el Operador OR = | y el AND = &
//OR 
console.log(1 | 3);  // 00000011 -> 3
console.log(1 | 4);  // 00000101 -> 5
console.log(2 | 3);  // 00000011 -> 3
console.log(4 | 6);  // 00000110 -> 6
console.log(3 | 6);  // 00000111 -> 7


//AND
console.log(1 & 3);  // 00000001 -> 1
console.log(1 & 4);  // 00000000 -> 0
console.log(2 & 3);  // 00000010 -> 2
console.log(4 & 6);  // 00000100 -> 4
console.log(3 & 6);  // 00000010 -> 2





Orden de Operadores
//Orden de Operaciones

//let resultado = 8/2*(2+2); //--> 16
let resultado = 8/(2*(2+2)); //--> 1

console.log(resultado);





Operador ternario

Operador ternario ? :
El operador ternario tiene esta forma:
condici√≥n ? valorSiEsTrue : valorSiEsFalse
Es lo mismo que un if...else, pero en una sola l√≠nea.

//Operador ternario
//Expresion ? "si es true" : "si es false"

let edad = 20;
let acceso = edad > 17 ? 'Permitir Ingreso' : 'No puede Ingresar';

console.log(acceso);

//este cumple con condicion es true o false segun sea la desicion






-----------------------------------------------------------------------------------------------------------
Control de Flujo

//Condicion IF
/*
if (condicion) {
    expresion
    
}
*/


let edad = 15;

if (edad > 17){
    alert("Es Mayor de Edad");
}

//Condicion ELSE

/*
let edad = 15;


if (edad > 17){ //condicion 1 --> if
    alert("Es Mayor de Edad");
} else {  //condicion 1 --> else es otra opcion de condicion
    alert("Es menor de edad");
}

*/

//ELSE IF --> es para a√±adir mas condiciones
let edad = 12;

if (edad > 17){ //condicion 1 --> if
    alert("Es Mayor de Edad");

} else if(edad >= 13) {  //condicion 2 --> else if es otra opcion de condicion
    alert("Tienes que venir con un adulto");

} else {  //condicion 3 --> else se vuelve otra opcion de condicion
    alert("No puedes Ingresar");
}


-----------------------------------------------------------------------------------------------------------
LOOPS O BUCLES
1- While
2- Do While 
3- For
4- For In 
5- For Of

Tipos de loops
Loop	              Uso
while	              mientras
do while	    ejecutar al menos 1 vez
for	               contador cl√°sico
for of	            recorrer arrays
for in	            recorrer objetos

1. While
//Condicion While

/*
while (condicion) {

}
*/

//cuales son los numeros pares
let i = 0;

while (i <= 10) {

    if (i % 2 === 0) {
        console.log("Numeros Pares: "+i); //muestra en consola
    }

    i++; //incremento de la variable i
}

console.log("Fuera del While");


Cuidado con los Loops Infinitos



2. Do While
Se ejecuta al menos una vez, aunque la condici√≥n sea falsa.
//Condicion Do While-- Evalua la condicion al final
// do {} while ();
//cuales son los numeros pares
let i = 2;

do {
    if (i % 2 === 0) {
        console.log("Numeros Pares: "+i); //muestra en consola
    }
    i++; //incremento de la variable i

} while (i <2);




3.For
//Condicion For -- Se compone de 3 expresiones
/*
for (inicio; condicion; incremento) {
    // c√≥digo
}
*/


for (let i = 2; i < 10; i++) { //incremento de la variable i
   
    if (i % 2 === 0) {
        console.log("Numeros Pares: "+i); //muestra en consola
    }

}



4. For Of 
//Condicion For Of

let frutas = ["limon", "tomate", "Naranja"];

for (fruta of frutas) { //aplicacion de of
   
     console.log(fruta); //muestra en consola fruta por fruta

}


//con while
let incremento = 0;
while (incremento < frutas.length){
    console.log(frutas[incremento]);
    incremento++;
}




5.For In
//For In -- Iterar las propiedades de un Objeto
let usuario = {
    id: 1,
    name: "John",
    edad: 20,

};

for (let propiedad in usuario){//uso de in
    //console.log(propiedad); //Mostrara las propiedades no los valores "propiedad"
    console.log(propiedad, usuario[propiedad]); //Mostrara las propiedades y valores "usuario[propiedad]""
}

propiedad = clave
usuario[propiedad] = valor
üìå NO recomendado para arrays, aunque funciona.


//se puede con array pero es mejor for of
let frutas = ["limon", "tomate", "Naranja"];

for (let indice in frutas) { //aplicacion de in
   
    console.log(indice, frutas[indice]); //muestra en consola fruta por fruta

}



Breack y Continuo
//Parar un Loop o Bucle
//Break--> Permite Salir del Loop
//Continue--> Permite Saltar una interaccion

let i = 0;

while(i < 6){
    i++;
    if(i === 2) {
        continue; //uso de continue
    }
    
    if ( i === 4){
        break; //uso de break
    }

    console.log(i);
}


----------------------------------------------------------------------------------------
switch

// Uso de Switch -- permite indicar donde queremos que vaya
//es parecido al if else, pero es msa corto

let accion = "listar";

switch (accion) {  
    case "listar":  //comparacion con la variable accion 
        console.log("Accion de Listar");
        break; //es como la salida

    case "guardar":  //comparacion con la variable accion
        console.log("Accion a Guardar");
        break;
    default:  //es como el else es la salida final
        console.log("Accion no reconocida");
}


CU√ÅNDO USAR CADA UNO
Situaci√≥n	                          Recomendaci√≥n
1 condici√≥n	                              if
Varias condiciones	                if / else if / else
Mismo valor, varias opciones	        switch
Repeticiones conocidas	                for
Repeticiones desconocidas	            while
Arrays	                               for...of
Objetos	                                for...in






----------------------------------------------------------------------------------------
PROGRAMACION ORIENTA A OBJETOS 

//Programacion orientada a objetos
let usuario = {
    email: "adelso@gmail.com",
    nombre: "Adelso",
    direccion: {
        calle: "Hola",
        numero: 15,
    },
    activo: true, 
    recuperarClave: function(){ //funcion anonima
        console.log("Recuperando clave");
    },
};


Los objetos representan cosas reales
Cada objeto tiene:
    Propiedades (datos)
    M√©todos (acciones)

üëâ En la vida real:
Un usuario tiene datos y hace cosas


usuario
‚îú‚îÄ‚îÄ email
‚îú‚îÄ‚îÄ nombre
‚îú‚îÄ‚îÄ activo
‚îú‚îÄ‚îÄ direccion
‚îÇ   ‚îú‚îÄ‚îÄ calle
‚îÇ   ‚îî‚îÄ‚îÄ numero
‚îî‚îÄ‚îÄ recuperarClave()

Acceso al objeto normal 
usuario.email
usuario.nombre
usuario.activo


Acceso a objeto dentro del objeto
usuario.direccion.calle
usuario.direccion.numero


Modificar una propiedad
usuario.activo = false;

Agregar una nueva
usuario.rol = "admin";

Eliminar una
delete usuario.email;



------------------------------------------------------------------------------------------------------
//Objeto Dinamico

const usuario = {  //no se puede cambiar el valor a la variable
    id: 1,
    
};

//Pero si se pueden modificar, agregar y eliminar, las propiedades
usuario.nombre = "Adelso";
usuario.guardar = function (){
    console.log("Guardando: "+usuario.nombre);
}

usuario.guardar();

delete usuario.nombre;
delete usuario.guardar;

console.log(usuario);



//Para no poder modificar el objeto se usa el metodo "Object.freeze()"
/*
const user1 = Object.freeze({id: 1});

user1.name = "Hola"; //Intenando agregar nueva propiedad --> no dejara
user1.id = 2; //Intenando cambiar un valor de una propiedad --> no dejara

console.log(user1);
*/

//pero si quisieramos poder cambiar los valores a las propiedades que tiene el objeto 
//se usa el metodo "Object.seal()"

const user1 = Object.seal({id: 1});

user1.name = "Hola"; //Intenando agregar nueva propiedad --> no dejara
user1.id = 2; //Intenando cambiar un valor de una propiedad --> SI DEJA

console.log(user1);



---------------------------------------------------------------------------------------------------

//Factory Functions
//permite crear objetos pero de forma sensilla y no repetitiva

function crearUsuario(name, email){

    return {
        email,  //email: email,
        name: name,  //name,
        activo: true,
        recuperarClave: function(){
            console.log("Recuperando Clave...");
        },
    };
}

let user1 = crearUsuario("Adelso", "adelso@gmail.com");
let user2 = crearUsuario("John", "hola@gmail.com");

console.log(user1, user2);







---------------------------------------------------------------------------------------------------
Funcion Constructora
Una funci√≥n especial que se usa para crear objetos usando new

//Funcion Constructora en js

//{id: 1, recuperarClave: funccton(){}}

function Usuario(){ // se debe de usar la primera letra MAYUSCULA --UpperCamelCase
    this.id = 1;  //this es el objeto que se est√° creando
    this.recuperarClave = function(){ //Metodo
        console.log("Recuperando Clave...");
    }
} 

let usuario = new Usuario(); //con "new" se crea un onjeto {} y eso se le asigna a "this"
                             //despues se vincual el prototipo de la funcion "Usuario()"
                             //esto returna de manera automatica this, sin colocarle el return manual
                             

console.log(usuario);


this NO crea objetos
üëâ new crea UN SOLO objeto
üëâ this es una referencia a ese mismo objeto

new crea el objeto una vez, this solo lo referencia.

---------------------------------------------------------------------------------------------------
Atajos Constructores

//objeto.construcctor


let obj = {

};

let obj1 = new Object();

/**
 * new Array(); []
 * new String(); "" '' ``
 * new Number();
 * new Boolean(); 
 */


function Usuario(){
    this.name = "Hola";
}

let user = new Usuario();

console.log(user.constructor);

//eval() --> ejecuta c√≥digo JavaScript que est√° escrito como TEXTO (string)
Ejemplo ULTRA simple
eval("2 + 2");
JS ve esto como:
2 + 2;

üëâ Resultado:
4

// uso de ".valeuOf()" para que devuela el valor real
let x = new Number(10);

console.log(x);          // Number {10}
console.log(x.valueOf()); // 10
üìå .valueOf() devuelve el valor real


Resumen 
    {} --> es un atajo de new Object()
Todo objeto tiene un constructor
    .constructor -->dice qui√©n lo cre√≥
    new --> crea un solo "objeto"
    .valueOf() --> devuelve el valor real



Atajos constructores (ESTO ES ORO)
Lo que escribes	        Lo que JS hace
{}	                    new Object()
[]	                    new Array()
"hola"	                new String("hola")
5	                    new Number(5)



---------------------------------------------------------------------------------------------------
Funciones
//Funciones son objeto de primera clase

function Usuario(nombre){
    this.nombre = nombre;
}

console.log(Usuario.name); // devuelve el nombre de la funcion
console.log(Usuario.length); // Cantidad de argumentos que recibe la funcion


const u = Usuario;
let user = new u("Adelso");

console.log(user);

function of(Fn, arg){
    return new Fn(arg);
}

let user1 = of(Usuario, "Hola");

console.log(user1);


function returned() {
    return function (){
        console.log("Hola");
    }
}

let saludo = returned();

saludo();




---------------------------------------------------------------------------------------------------
Funciones --> Function 

function Punto(x,y){
    this.x = x;
    this.y = y;

    this.dibujar = function(){
        console.log("Dibujando....");
    }
}

//para poder guardar el objeto se crea esta varible y se le asigna
//valores random solo para despues ser sustiuidas por el objeto de la funcion
//para poder extender objetos y funciones
let punto = { z: 7};

//el metodo ".call()"
//Punto.call(punto, 1, 2);//el "punto" que estan dentro del parentesis seria "this"

//tambien esta el metodo ".apply()"
Punto.apply(punto, [1, 2]);//pero los parametros se deben de pasar en array []

//ahora si dejara mostrarlo en consola
console.log(punto);




/* NO USAR
const Point = new Function("x", "y", `
    this.x = x;
    this.y = y;

    this.dibujar = function(){
        console.log("Dibujando....");
    }
    `);

const p = new Point(1, 2);

console.log(p);

*/


Ejemplo 2:
function activar(){
    this.activo = true;
}

let user = {};
activar.call(user);


call y apply permiten ejecutar una funci√≥n usando cualquier objeto como this



---------------------------------------------------------------------------------------------------
Valor y Referencia


//Referencias 

/* datos primitivos --> se pasan por VALOR
let a = 1;
let b = a;

b++; 
console.log(a , b);
*/



/* objetos --> se pasan por REFERENCIA
let a = {};
let b = a;

b.prop = 1;

console.log(a, b);
*/


//Funciones + primitivos
/*
let a = 1;

function suma(n){ //n es otra variable que se crea internamente 
    n++;
}

suma(a);
console.log(a);  // por eso es que aca pasa "1" y no aumenta


Qu√© pasa:
a es primitivo ‚Üí se copia el valor
n es otra variable
n++ NO afecta a a

üì§ Resultado:
1
üëâ No se modifica el original



*/

//Funciones + objetos (el caso importante)
let a = {
    prop: 1,
};

function suma(n){ //n es la referencia del objeto 
    n.prop++;  //entra a la referencia que se le pasa y aumenta el numero
}

suma(a);
console.log(a);  // por eso es que aca pasa "2" y si aumenta


Qu√© pasa paso a paso:
1Ô∏è‚É£ a apunta a un objeto
2Ô∏è‚É£ n recibe la misma referencia
3Ô∏è‚É£ n.prop++ modifica el objeto
4Ô∏è‚É£ a ve el cambio

üì§ Resultado:
{ prop: 2 }

üî• La funci√≥n puede modificar el objeto original



Regla de ORO (aprend√©tela)
üîë Primitivos se copian, objetos se comparten

O m√°s t√©cnica:
JavaScript pasa primitivos por valor
y objetos por referencia (compartida)


-----------------------------------------------------------------------------------------------------
Listar Propiedades
const punto ={
    x: 10,
    y: 15,
    dibujar: function(){ //metodo tambien puede ser "dibujar(){}"
        console.log("Dibujando...");
    }
};

//delete punto.dibujar;

//Verificar si el metodo existe
if ("dibujar" in punto){
    punto.dibujar();
}


//Object Tambien tiene metodos
// ".keys()" ".entrices()"

//let keys = Object.keys(punto);
//es lo mismo
//console.log(Object.keys(punto));

for(let llave of Object.keys(punto)){
    console.log(llave, punto[llave]);
}


//par acceder a la propiedades de un objeto cuando no se conocen
for (let entry of Object.entries(punto)){
    console.log(entry);
}